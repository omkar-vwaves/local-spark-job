package com.enttribe.pm.job.alert;

import java.util.ArrayList;
import java.util.Collections;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.spark.sql.Row;
import org.apache.spark.sql.RowFactory;
import org.apache.spark.sql.api.java.UDF19;
import org.apache.spark.sql.types.DataType;
import org.apache.spark.sql.types.DataTypes;
import org.apache.spark.sql.types.StructField;
import org.json.JSONArray;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.enttribe.sparkrunner.context.JobContext;
import com.enttribe.sparkrunner.udf.AbstractUDF;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;

public class AlertUDF implements
        UDF19<String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, String, List<Row>>,
        AbstractUDF {

    public JobContext jobcontext;
    private static final long serialVersionUID = 1L;
    private static final Logger logger = LoggerFactory.getLogger(AlertUDF.class);

    @Override
    public String getName() {
        return "AlertUDF";
    }

    @Override
    public DataType getReturnType() {
        List<StructField> fields = new ArrayList<>();
        fields.add(DataTypes.createStructField("INPUT_CONFIGURATIONS", DataTypes.StringType, true));
        fields.add(DataTypes.createStructField("EXTRACTED_PARAMETERS", DataTypes.StringType, true));
        fields.add(DataTypes.createStructField("NODE_AND_AGGREGATION_DETAILS", DataTypes.StringType, true));
        return DataTypes.createArrayType(DataTypes.createStructType(fields));
    }

    @Override
    public List<Row> call(String expression, String description, String alarmIdentifier, String alarmName,
            String classification, String netype, String defaultSeverity, String emsType, String alarmId,
            String serviceAffecting, String probableCause, String manualCleared, String eventType, String domain,
            String vendor, String technology, String correlationEnable, String alarmGroup, String configuration)
            throws JsonProcessingException {

        List<Row> rowList = new ArrayList<>();
        Map<String, String> inputMap = new LinkedHashMap<>();

        inputMap.put("EXPRESSION", trimSafe(expression));
        inputMap.put("DESCRIPTION", trimSafe(description));
        inputMap.put("ALARM_IDENTIFIER", trimSafe(alarmIdentifier));
        inputMap.put("ALARM_NAME", trimSafe(alarmName));
        inputMap.put("CLASSIFICATION", trimSafe(classification));
        inputMap.put("NETYPE", trimSafe(netype));
        inputMap.put("DEFAULT_SEVERITY", trimSafe(defaultSeverity));
        inputMap.put("EMS_TYPE", trimSafe(emsType));
        inputMap.put("ALARM_ID", trimSafe(alarmId));
        inputMap.put("SERVICE_AFFECTING", trimSafe(serviceAffecting));
        inputMap.put("PROBABLE_CAUSE", trimSafe(probableCause));
        inputMap.put("MANUAL_CLEARED", trimSafe(manualCleared));
        inputMap.put("EVENT_TYPE", trimSafe(eventType));
        inputMap.put("DOMAIN", trimSafe(domain));
        inputMap.put("VENDOR", trimSafe(vendor));
        inputMap.put("TECHNOLOGY", trimSafe(technology));
        inputMap.put("CORRELATION_ENABLE", trimSafe(correlationEnable));
        inputMap.put("ALARM_GROUP", trimSafe(alarmGroup));
        inputMap.put("CONFIGURATION", trimSafe(configuration));

        logger.info("Input Map: {}", inputMap);

        processPMAlertInputMap(inputMap, rowList, jobcontext);

        return rowList;
    }

    private static String trimSafe(String value) {
        return value == null ? "" : value.trim();
    }

    private static void processPMAlertInputMap(Map<String, String> inputMap, List<Row> rowList, JobContext jobContext)
            throws JsonProcessingException {

        Map<String, String> extractedParametersMap = extractParametersFromConfiguration(inputMap, jobContext);
        Map<String, String> nodeAndAggregationDetailsMap = getNodeAndAggregationDetails(inputMap);

        String inputConfig = new ObjectMapper().writeValueAsString(inputMap);
        String extractedParameters = new ObjectMapper().writeValueAsString(extractedParametersMap);
        String nodeAndAggregationDetails = new ObjectMapper().writeValueAsString(nodeAndAggregationDetailsMap);

        jobContext.setParameters("INPUT_CONFIGURATIONS", inputConfig);
        jobContext.setParameters("EXTRACTED_PARAMETERS", extractedParameters);
        jobContext.setParameters("NODE_AND_AGGREGATION_DETAILS", nodeAndAggregationDetails);

        Row row = RowFactory.create(inputConfig, extractedParameters, nodeAndAggregationDetails);
        rowList.add(row);

    }

    private static Map<String, String> getNodeAndAggregationDetails(Map<String, String> inputMap) {

        Map<String, String> nodeAndAggregationDetails = new LinkedHashMap<>();

        try {
            String fixedJson = inputMap.get("CONFIGURATION").replace("'", "\"").replaceAll("^\"|\"$", "");

            logger.info("fixedJson : {}", fixedJson);
            JSONObject jsonObject = new JSONObject(fixedJson);

            JSONArray geoL1JSONArray = jsonObject.getJSONArray("geography_l1");
            JSONArray geoL2JSONArray = jsonObject.getJSONArray("geography_l2");
            JSONArray geoL3JSONArray = jsonObject.getJSONArray("geography_l3");
            JSONArray geoL4JSONArray = jsonObject.getJSONArray("geography_l4");
            JSONArray nodeArray = jsonObject.getJSONArray("node");

            List<String> geoL1List = getStringListFromArray(geoL1JSONArray);
            List<String> geoL2List = getStringListFromArray(geoL2JSONArray);
            List<String> geoL3List = getStringListFromArray(geoL3JSONArray);
            List<String> geoL4List = getStringListFromArray(geoL4JSONArray);
            List<String> nodeList = getStringListFromArray(nodeArray);

            String geoL1 = geoL1List.get(0) != null && !geoL1List.get(0).isEmpty() ? geoL1List.get(0).toUpperCase()
                    : "";
            String geoL2 = geoL2List.get(0) != null && !geoL2List.get(0).isEmpty() ? geoL2List.get(0).toUpperCase()
                    : "";
            String geoL3 = geoL3List.get(0) != null && !geoL3List.get(0).isEmpty() ? geoL3List.get(0).toUpperCase()
                    : "";
            String geoL4 = geoL4List.get(0) != null && !geoL4List.get(0).isEmpty() ? geoL4List.get(0).toUpperCase()
                    : "";
            String node = nodeList.get(0) != null && !nodeList.get(0).isEmpty() ? nodeList.get(0).toUpperCase() : "";

            String netype = jsonObject.getString("netype");
            netype = netype != null && !netype.isEmpty() ? netype.toUpperCase() : "";

            logger.info("Provided Node & Aggragtaion Details: geoL1={}, geoL2={}, geoL3={}, geoL4={}, node={}",
                    geoL1, geoL2, geoL3, geoL4, node);

            nodeAndAggregationDetails.put("geoL1", geoL1);
            nodeAndAggregationDetails.put("geoL2", geoL2);
            nodeAndAggregationDetails.put("geoL3", geoL3);
            nodeAndAggregationDetails.put("geoL4", geoL4);
            nodeAndAggregationDetails.put("node", node);
            nodeAndAggregationDetails.put("netype", netype);
            nodeAndAggregationDetails.put("geoL1List", geoL1List.toString());
            nodeAndAggregationDetails.put("geoL2List", geoL2List.toString());
            nodeAndAggregationDetails.put("geoL3List", geoL3List.toString());
            nodeAndAggregationDetails.put("geoL4List", geoL4List.toString());
            nodeAndAggregationDetails.put("nodeList", nodeList.toString());

            String isGeoL1MultiSelect = !geoL1.contains("CLUBBED") && !geoL1.contains("INDIVIDUAL") ? "true" : "false";
            String isGeoL2MultiSelect = !geoL2.contains("CLUBBED") && !geoL2.contains("INDIVIDUAL") ? "true" : "false";
            String isGeoL3MultiSelect = !geoL3.contains("CLUBBED") && !geoL3.contains("INDIVIDUAL") ? "true" : "false";
            String isGeoL4MultiSelect = !geoL4.contains("CLUBBED") && !geoL4.contains("INDIVIDUAL") ? "true" : "false";
            String isNodeMultiSelect = !node.contains("CLUBBED") && !node.contains("INDIVIDUAL") ? "true" : "false";

            nodeAndAggregationDetails.put("isGeoL1MultiSelect", isGeoL1MultiSelect);
            nodeAndAggregationDetails.put("isGeoL2MultiSelect", isGeoL2MultiSelect);
            nodeAndAggregationDetails.put("isGeoL3MultiSelect", isGeoL3MultiSelect);
            nodeAndAggregationDetails.put("isGeoL4MultiSelect", isGeoL4MultiSelect);
            nodeAndAggregationDetails.put("isNodeMultiSelect", isNodeMultiSelect);

        } catch (Exception e) {
            logger.error("Error in getting Node and Aggregation Details, Message: {}, Error: {}", e.getMessage(), e);
        }

        return nodeAndAggregationDetails;

    }

    private static Map<String, String> extractParametersFromConfiguration(Map<String, String> inputMap,
            JobContext jobContext) {

        try {

            String configuration = inputMap.get("CONFIGURATION");
            configuration = configuration.replace("\"", "");

            Map<String, String> parameters = new LinkedHashMap<>();

            JSONObject configJson = new JSONObject(configuration);

            JSONArray nodeJSON = configJson.getJSONArray("node");
            List<String> nodeArray = getStringListFromArray(nodeJSON);
            String node = nodeArray.get(0);

            String classification = configJson.getString("classification");
            classification = classification != null && !classification.isEmpty() ? classification.toUpperCase()
                    : inputMap.get("CLASSIFICATION");

            String serviceAffecting = configJson.getString("serviceaffecting");
            serviceAffecting = serviceAffecting != null && !serviceAffecting.isEmpty() ? serviceAffecting.toLowerCase()
                    : inputMap.get("SERVICE_AFFECTING");

            serviceAffecting = (serviceAffecting.equalsIgnoreCase("true")) ? "0" : "1";

            String severity = "";
            if (configJson.has("priority")) {
                severity = configJson.getString("priority");
            } else {
                severity = inputMap.get("DEFAULT_SEVERITY");
            }

            String upperSeverity = severity.toUpperCase();
            if ("EMERGENCY".equalsIgnoreCase(upperSeverity)) {
                severity = "CRITICAL";
            }

            String outOfLast = "0";
            String instances = "0";

            JSONObject consistencyJson = configJson.getJSONObject("Consistency");
            if (consistencyJson.has("outOfLast") && !consistencyJson.getString("outOfLast").isEmpty()) {
                outOfLast = consistencyJson.getString("outOfLast");
            }

            if (consistencyJson.has("Instances") && !consistencyJson.getString("Instances").isEmpty()) {
                instances = consistencyJson.getString("Instances");
            }

            JSONArray cellArray = configJson.getJSONArray("cells");
            JSONArray geoL1Array = configJson.getJSONArray("geography_l1");
            JSONArray geoL2Array = configJson.getJSONArray("geography_l2");
            JSONArray geoL3Array = configJson.getJSONArray("geography_l3");
            JSONArray geoL4Array = configJson.getJSONArray("geography_l4");

            List<String> cellList = getStringListFromArray(cellArray);
            List<String> geoL1List = getStringListFromArray(geoL1Array);
            List<String> geoL2List = getStringListFromArray(geoL2Array);
            List<String> geoL3List = getStringListFromArray(geoL3Array);
            List<String> geoL4List = getStringListFromArray(geoL4Array);

            String level = getLevelForReport(geoL1List, geoL2List, geoL3List, geoL4List, cellList, node,
                    geoL1List, inputMap.get("DOMAIN"));

            String isNodeLevel = "false";
            if (!level.contains("L0") && !level.contains("L1") && !level.contains("L2")
                    && !level.contains("L3") && !level.contains("L4")) {

                if (geoL1List.get(0).toUpperCase().equalsIgnoreCase("INDIA")) {
                    isNodeLevel = "false";
                } else {
                    isNodeLevel = "true";
                }

            }

            String dataLevelAppender = jobContext.getParameter("ROW_KEY_APPENDER");
            logger.info("ðŸ“Š Data Level Appender: {}", dataLevelAppender);

            String datalevel = "";

            switch (level) {
                case "L0": {
                    datalevel = "L0" + "_" + dataLevelAppender;
                    break;
                }
                case "L1": {
                    datalevel = "L1" + "_" + dataLevelAppender;
                    break;
                }
                case "L2": {
                    datalevel = "L2" + "_" + dataLevelAppender;
                    break;
                }
                case "L3": {
                    datalevel = "L3" + "_" + dataLevelAppender;
                    break;
                }
                case "L4": {
                    datalevel = "L4" + "_" + dataLevelAppender;
                    break;
                }
                default: {
                    datalevel = level + "_" + dataLevelAppender;
                    break;
                }
            }

            logger.info("Generated DataLevel is : {}", datalevel);

            parameters.put("instances", instances);
            parameters.put("outOfLast", outOfLast);
            parameters.put("datalevel", datalevel);
            parameters.put("level", level);
            parameters.put("geoL1List", geoL1List.toString());
            parameters.put("geoL2List", geoL2List.toString());
            parameters.put("geoL3List", geoL3List.toString());
            parameters.put("geoL4List", geoL4List.toString());
            parameters.put("CLASSIFICATION", classification);
            parameters.put("SEVERITY", severity);
            parameters.put("ACTUAL_SEVERITY", inputMap.get("DEFAULT_SEVERITY"));
            parameters.put("SUBENTITY", level);

            parameters.put("DOMAIN", inputMap.get("DOMAIN").toUpperCase());
            parameters.put("VENDOR", inputMap.get("VENDOR").toUpperCase());
            parameters.put("TECHNOLOGY", inputMap.get("TECHNOLOGY").toUpperCase());

            parameters.put("TIMESTAMP", jobContext.getParameter("TIMESTAMP"));
            parameters.put("isNodeLevel", isNodeLevel);

            parameters.put("EXPRESSION", inputMap.get("EXPRESSION"));
            parameters.put("ALARM_EXTERNAL_ID", inputMap.get("ALARM_IDENTIFIER"));
            parameters.put("ALARM_CODE", inputMap.get("ALARM_ID"));
            parameters.put("ALARM_NAME", inputMap.get("ALARM_NAME"));

            parameters.put("PROBABLE_CAUSE", inputMap.get("PROBABLE_CAUSE"));
            parameters.put("DESCRIPTION", inputMap.get("DESCRIPTION"));
            parameters.put("ALARM_GROUP", inputMap.get("ALARM_GROUP"));
            parameters.put("SERVICE_AFFECTING", serviceAffecting);

            String manuallyCloseable = inputMap.get("MANUAL_CLEARED");
            if (manuallyCloseable != null && manuallyCloseable.equalsIgnoreCase("true")) {
                manuallyCloseable = "1";
            } else {
                manuallyCloseable = "0";
            }

            String correlationEnable = inputMap.get("CORRELATION_ENABLE");
            if (correlationEnable != null && correlationEnable.equalsIgnoreCase("true")) {
                correlationEnable = "1";
            } else {
                correlationEnable = "0";
            }

            parameters.put("MANUALLY_CLOSEABLE", manuallyCloseable);
            parameters.put("CORRELATION_FLAG", correlationEnable);
            parameters.put("EVENT_TYPE", inputMap.get("EVENT_TYPE"));
            parameters.put("SENDER_NAME", inputMap.get("EMS_TYPE"));

            String cqlTableName = generateCQLTableNameBasedOnFrequency(jobContext);
            parameters.put("cqlTableName", cqlTableName);

            String expression = inputMap.get("EXPRESSION");
            List<String> kpiCodeList = getKPICodeListFromExpression(expression);

            parameters.put("kpiCodeList", kpiCodeList.toString());

            return parameters;

        } catch (Exception e) {
            return new LinkedHashMap<>();
        }
    }

    public static String getLevelForReport(List<String> geoL1List, List<String> geoL2List, List<String> geoL3List,
            List<String> geoL4List, List<String> cells, String node,
            List<String> coreDomains, String DOMAIN) {

        boolean isClubbed = node != null && node.toUpperCase().contains("CLUBBED");

        boolean isCoreDomain = coreDomains.contains(DOMAIN);
        String geoL1 = geoL1List != null && !geoL1List.isEmpty() ? geoL1List.get(0).toUpperCase() : "";
        String geoL2 = geoL2List != null && !geoL2List.isEmpty() ? geoL2List.get(0).toUpperCase() : "";
        String geoL3 = geoL3List != null && !geoL3List.isEmpty() ? geoL3List.get(0).toUpperCase() : "";
        String geoL4 = geoL4List != null && !geoL4List.isEmpty() ? geoL4List.get(0).toUpperCase() : "";

        if (!isClubbed && !geoL1.equalsIgnoreCase("INDIA")) {
            return getNodeName(node);
        }

        if (geoL1.equalsIgnoreCase("INDIA")) {
            return "L0";
        }

        if (!geoL1.contains("CLUBBED")) {
            if (!geoL2.contains("CLUBBED")) {
                if (!geoL3.contains("CLUBBED")) {
                    if (!geoL4.contains("CLUBBED")) {
                        return isClubbed ? "L4" : getNodeName(node);
                    } else {
                        return "L3";
                    }
                } else {
                    return "L2";
                }
            } else {
                if (isCoreDomain) {
                    return isClubbed ? "L1" : getNodeName(node);
                } else {
                    return geoL1.contains("India") ? "L0" : "L1";
                }
            }
        }

        return "L0";
    }

    public static String getNodeName(String nodeString) {

        if (nodeString == null) {
            return "";
        }

        int lastDashIndex = nodeString.lastIndexOf('-');
        String part = (lastDashIndex != -1) ? nodeString.substring(0, lastDashIndex) : nodeString;

        int spaceIndex = part.indexOf(' ');
        String node = (spaceIndex != -1) ? part.substring(spaceIndex + 1) : part;

        node = node.trim().toUpperCase();
        return node.replace(" ", "-");
    }

    private static List<String> getKPICodeListFromExpression(String expression) {

        if (expression == null || expression.isEmpty()) {
            return new ArrayList<>();
        }

        List<String> kpiCodes = new ArrayList<>();
        Pattern pattern = Pattern.compile("KPI#(\\d+)");
        Matcher matcher = pattern.matcher(expression);

        while (matcher.find()) {
            String kpiCode = matcher.group(1);
            if (!kpiCodes.contains(kpiCode)) {
                kpiCodes.add(kpiCode);
            }
        }
        return kpiCodes;
    }

    private static String generateCQLTableNameBasedOnFrequency(JobContext jobContext) {

        String jobFrequency = jobContext.getParameter("JOB_FREQUENCY");

        return switch (jobFrequency.toUpperCase()) {
            case "15 MIN" -> "combinequarterlypm";
            case "PERHOUR" -> "combinehourlypm";
            case "PERDAY" -> "combinedailypm";
            case "PERWEEK" -> "combineweeklypm";
            case "PERMONTH" -> "combinemonthlypm";
            default -> "combinequarterlypm";
        };
    }

    public static List<String> getStringListFromArray(JSONArray array) {

        if (array == null || array.isEmpty()) {
            return Collections.emptyList();
        }

        List<String> list = new ArrayList<>(array.length());

        for (int i = 0; i < array.length(); i++) {

            try {
                list.add(array.getString(i));
            } catch (Exception e) {
                logger.error("Error Parsing String from JSONArray At index {}, Message: {}, Error: {}", i,
                        e.getMessage(), e);
            }

        }

        return list;
    }

}
