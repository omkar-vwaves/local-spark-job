package com.enttribe.pm.job.report.otf;

import com.enttribe.sparkrunner.context.JobContext;
import com.enttribe.sparkrunner.processors.Processor;
import com.fasterxml.jackson.databind.ObjectMapper;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.time.LocalDateTime;
import java.time.ZoneOffset;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;

import org.apache.spark.sql.Dataset;
import org.apache.spark.sql.Row;
import org.json.JSONArray;
import org.json.JSONObject;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class OTFExtractConfiguration extends Processor {

   private static final Logger logger = LoggerFactory.getLogger(OTFExtractConfiguration.class);

   private static final String FALLBACK_SPARK_PM_JDBC_DRIVER = "org.mariadb.jdbc.Driver";
   private static final String FALLBACK_SPARK_PM_JDBC_URL = "jdbc:mysql://mysql-nst-cluster.nstdb.svc.cluster.local:6446/PERFORMANCE_A_LAB?autoReconnect=true";
   private static final String FALLBACK_SPARK_PM_JDBC_USERNAME = "PERFORMANCE";
   private static final String FALLBACK_SPARK_PM_JDBC_PASSWORD = "perform!123";

   public OTFExtractConfiguration() {
      super();
      logger.info("OTFExtractConfiguration Constructor Called!");
   }

   public OTFExtractConfiguration(Dataset<Row> dataFrame, int processorId, String processorName) {
      super(processorId, processorName);
      logger.info("OTFExtractConfiguration Constructor Called with Input DataFrame With ID: {} and Process Name: {}",
            processorId, processorName);
   }

   @Override
   public Dataset<Row> executeAndGetResultDataframe(JobContext jobContext) throws Exception {

      logger.info("OTFExtractConfiguration Execution Started !");

      if (this.dataFrame == null && this.dataFrame.isEmpty()) {
         logger.error("OTFExtractConfiguration Execution Failed! Input DataFrame is Empty!");
         return this.dataFrame;
      }

      List<Row> rowList = this.dataFrame.collectAsList();
      if (rowList.isEmpty()) {
         logger.error("OTFExtractConfiguration Execution Failed! Input DataFrame is Empty!");
         return this.dataFrame;
      }

      Row row = rowList.get(0);

      Map<String, String> reportWidgetDetailsMap = getReportWidgetDetailsMap(row, jobContext);
      logger.info("üìä Report Widget Details Map: {}", reportWidgetDetailsMap);

      Map<String, String> nodeAndAggregationDetailsMap = getNodeAndAggregationDetails(reportWidgetDetailsMap,
            jobContext);
      logger.info("üìä Node And Aggregation Details Map: {}", nodeAndAggregationDetailsMap);

      Map<String, String> extraParametersMap = getExtraParameters(reportWidgetDetailsMap, jobContext);
      logger.info("üìä Extra Parameters Map: {}", extraParametersMap);

      String trinoOrcFilePaths = getTrinoOrcFilePaths(extraParametersMap, reportWidgetDetailsMap, jobContext);

      Map<String, String> metaColumnsMap = getMetaColumnsMap(extraParametersMap);
      logger.info("üìä Meta Columns Map: {}", metaColumnsMap);

      Map<String, String> kpiDetailsMap = new LinkedHashMap<>();
      Map<String, String> kpiCodeWithKpiNameMap = new LinkedHashMap<>();
      Map<String, String> counterDetailsMap = new LinkedHashMap<>();
      Map<String, String> counterIdWithCounterNameMap = new LinkedHashMap<>();
      List<String> kpiCodeList = new ArrayList<>();
      List<String> counterIdList = new ArrayList<>();
      initializeKPICounterDetails(reportWidgetDetailsMap, kpiDetailsMap, counterDetailsMap, kpiCodeList, counterIdList,
            kpiCodeWithKpiNameMap, counterIdWithCounterNameMap);
      String kpiCodeCommaSeparated = kpiCodeList.stream().collect(Collectors.joining(","));
      logger.info("üìä KPI Code Comma Separated: {}", kpiCodeCommaSeparated);
      String counterIdCommaSeparated = counterIdList.stream().collect(Collectors.joining(","));
      logger.info("üìä Counter Id Comma Separated: {}", counterIdCommaSeparated);

      jobContext.setParameters("KPI_CODE_COMMA_SEPARATED", kpiCodeCommaSeparated);
      jobContext.setParameters("COUNTER_ID_COMMA_SEPARATED", counterIdCommaSeparated);

      logger.info("üìä KPI Details Map: {}", kpiDetailsMap);
      logger.info("üìä Counter Details Map: {}", counterDetailsMap);
      logger.info("üìä KPI Code List: {}", kpiCodeList);
      logger.info("üìä Counter Id List: {}", counterIdList);
      logger.info("üìä KPI Code With KPI Name Map: {}", kpiCodeWithKpiNameMap);
      logger.info("üìä Counter Id With Counter Name Map: {}", counterIdWithCounterNameMap);

      String reportWidgetDetails = new ObjectMapper().writeValueAsString(reportWidgetDetailsMap);
      String nodeAndAggregationDetails = new ObjectMapper().writeValueAsString(nodeAndAggregationDetailsMap);
      String extraParameters = new ObjectMapper().writeValueAsString(extraParametersMap);
      String metaColumns = new ObjectMapper().writeValueAsString(metaColumnsMap);
      String kpiDetails = new ObjectMapper().writeValueAsString(kpiDetailsMap);
      String counterDetails = new ObjectMapper().writeValueAsString(counterDetailsMap);
      String kpiCodeWithKpiName = new ObjectMapper().writeValueAsString(kpiCodeWithKpiNameMap);
      String counterIdWithCounterName = new ObjectMapper().writeValueAsString(counterIdWithCounterNameMap);

      jobContext.setParameters("REPORT_WIDGET_DETAILS", reportWidgetDetails);
      jobContext.setParameters("NODE_AND_AGGREGATION_DETAILS", nodeAndAggregationDetails);
      jobContext.setParameters("EXTRA_PARAMETERS", extraParameters);
      jobContext.setParameters("META_COLUMNS", metaColumns);
      jobContext.setParameters("KPI_DETAILS", kpiDetails);
      jobContext.setParameters("COUNTER_DETAILS", counterDetails);
      jobContext.setParameters("TRINO_ORC_FILE_PATHS", trinoOrcFilePaths);
      jobContext.setParameters("KPI_CODE_LIST", kpiCodeList.toString());
      jobContext.setParameters("COUNTER_ID_LIST", counterIdList.toString());
      jobContext.setParameters("KPI_CODE_WITH_KPI_NAME_MAP", kpiCodeWithKpiName);
      jobContext.setParameters("COUNTER_ID_WITH_COUNTER_NAME_MAP", counterIdWithCounterName);

      Map<String, Map<String, String>> counterInfoMap = getCounterInfoMap(jobContext, reportWidgetDetailsMap,
            kpiCodeCommaSeparated);
      logger.info("üìä Counter Info Map: {}", counterInfoMap);
      String COUNTER_INFO_MAP_JSON = new ObjectMapper().writeValueAsString(counterInfoMap);

      String CATEGORY_LIST = counterInfoMap.entrySet().stream().map(e -> e.getValue().get("CATEGORY_NAME"))
            .distinct().collect(Collectors.joining(","));

      logger.info("üìä Category List: {}", CATEGORY_LIST);

      Map<String, List<Map<String, String>>> catgoryInfoMap = getCatgoryInfoMap(counterInfoMap);
      logger.info("üìä Catgory Info Map: {}", catgoryInfoMap);
      String CATEGORY_INFO_MAP_JSON = new ObjectMapper().writeValueAsString(catgoryInfoMap);

      jobContext.setParameters("CATEGORY_LIST", CATEGORY_LIST);
      jobContext.setParameters("COUNTER_INFO_MAP", COUNTER_INFO_MAP_JSON);
      jobContext.setParameters("CATEGORY_INFO_MAP", CATEGORY_INFO_MAP_JSON);

      String fromDate = extraParametersMap.get("FROM_DATE");
      String toDate = extraParametersMap.get("TO_DATE");

      String frequency = reportWidgetDetailsMap.get("FREQUENCY");
      jobContext.setParameters("FREQUENCY", frequency);

      String timeKeysCommaSeparated = getTimeKeys(fromDate, toDate, jobContext);
      logger.info("üìä Time Keys Comma Separated: {}", timeKeysCommaSeparated);
      jobContext.setParameters("TIME_KEYS_COMMA_SEPARATED", timeKeysCommaSeparated);

      getPMCounterVariableAggrQuery(jobContext, frequency, timeKeysCommaSeparated);

      String kpiCodesCommaSeparated = kpiCodeList.stream().collect(Collectors.joining(","));
      logger.info("üìä KPI Codes Comma Separated: {}", kpiCodesCommaSeparated);

      Map<String, Map<String, String>> kpiFormulaFinalMap = getKpiFormulaMap(kpiCodesCommaSeparated,
            reportWidgetDetailsMap, jobContext);

      logger.info("üìä KPI Formula Final Map: {}", kpiFormulaFinalMap);
      String KPI_FORMULA_MAP_JSON = new ObjectMapper().writeValueAsString(kpiFormulaFinalMap);
      jobContext.setParameters("KPI_FORMULA_MAP", KPI_FORMULA_MAP_JSON);

      String aggregationLevel = getAggregationLevel(reportWidgetDetailsMap, nodeAndAggregationDetailsMap);
      logger.info("üìä Aggregation Level: {} Set to Job Context Successfully!", aggregationLevel);        
      // jobContext.setParameters("AGGREGATION_LEVEL", aggregationLevel);
      jobContext.setParameters("AGGREGATION_LEVEL", "L0");


      String finalCounterInfo = counterInfoMap.entrySet().stream()
            .map(e -> "C" + e.getValue().get("SEQUENCE_NO") + "#" + e.getValue().get("PM_COUNTER_VARIABLE_ID_PK"))
            .distinct().collect(Collectors.joining(","));

      logger.info("üìä Final Counter Info: {}", finalCounterInfo);

      jobContext.setParameters("FINAL_COUNTER_INFO", finalCounterInfo);

      return this.dataFrame;
   }

   private static String getAggregationLevel(Map<String, String> reportWidgetDetailsMap,
         Map<String, String> nodeAndAggregationDetails) {

      String aggregationLevel = "H1";

      String geoL1 = nodeAndAggregationDetails.get("GEOGRAPHY_L1");
      String geoL2 = nodeAndAggregationDetails.get("GEOGRAPHY_L2");
      String geoL3 = nodeAndAggregationDetails.get("GEOGRAPHY_L3");
      String geoL4 = nodeAndAggregationDetails.get("GEOGRAPHY_L4");
      String node = nodeAndAggregationDetails.get("NODE");

      boolean isGeoL1MultiSelect = Boolean.parseBoolean(nodeAndAggregationDetails.get("IS_GEOGRAPHY_L1_MULTI_SELECT"));
      boolean isGeoL2MultiSelect = Boolean.parseBoolean(nodeAndAggregationDetails.get("IS_GEOGRAPHY_L2_MULTI_SELECT"));
      boolean isGeoL3MultiSelect = Boolean.parseBoolean(nodeAndAggregationDetails.get("IS_GEOGRAPHY_L3_MULTI_SELECT"));
      boolean isGeoL4MultiSelect = Boolean.parseBoolean(nodeAndAggregationDetails.get("IS_GEOGRAPHY_L4_MULTI_SELECT"));

      String isNodeNameListEmpty = nodeAndAggregationDetails.get("IS_NODE_NAME_LIST_EMPTY");

      if (isNodeNameListEmpty.equals("false")) {
         logger.info("CASE 0: NODE NAME LIST IS NOT EMPTY");
         return "H1";
      }

      if (geoL1.contains("CLUBBED") && geoL2.contains("CLUBBED") && geoL3.contains("CLUBBED")
            && geoL4.contains("CLUBBED") && node.contains("CLUBBED")) {

         logger.info("CASE 1: CLUBBED, CLUBBED, CLUBBED, CLUBBED, CLUBBED");
         aggregationLevel = "L0";

      } else if (geoL1.contains("CLUBBED") && geoL2.contains("CLUBBED") && geoL3.contains("CLUBBED")
            && geoL4.contains("CLUBBED") && node.contains("INDIVIDUAL")) {

         logger.info("CASE 2: CLUBBED, CLUBBED, CLUBBED, CLUBBED, INDIVIDUAL");
         aggregationLevel = "H1";

      } else if (geoL1.contains("INDIVIDUAL") && geoL2.contains("CLUBBED") && geoL3.contains("CLUBBED")
            && geoL4.contains("CLUBBED") && node.contains("CLUBBED")) {

         logger.info("CASE 3: INDIVIDUAL, CLUBBED, CLUBBED, CLUBBED, CLUBBED");
         aggregationLevel = "L1";
      } else if (geoL1.contains("INDIVIDUAL") && geoL2.contains("CLUBBED") && geoL3.contains("CLUBBED")
            && geoL4.contains("CLUBBED") && node.contains("INDIVIDUAL")) {

         logger.info("CASE 4: INDIVIDUAL, CLUBBED, CLUBBED, CLUBBED, INDIVIDUAL");
         aggregationLevel = "H1";
      } else if (geoL1.contains("INDIVIDUAL") && geoL2.contains("INDIVIDUAL") && geoL3.contains("CLUBBED")
            && geoL4.contains("CLUBBED") && node.contains("CLUBBED")) {

         logger.info("CASE 5: INDIVIDUAL, INDIVIDUAL, CLUBBED, CLUBBED, CLUBBED");
         aggregationLevel = "L2";
      } else if (geoL1.contains("INDIVIDUAL") && geoL2.contains("INDIVIDUAL") && geoL3.contains("CLUBBED")
            && geoL4.contains("CLUBBED") && node.contains("INDIVIDUAL")) {

         logger.info("CASE 6: INDIVIDUAL, INDIVIDUAL, CLUBBED, CLUBBED, INDIVIDUAL");
         aggregationLevel = "H1";
      } else if (geoL1.contains("INDIVIDUAL") && geoL2.contains("INDIVIDUAL") && geoL3.contains("INDIVIDUAL")
            && geoL4.contains("CLUBBED") && node.contains("CLUBBED")) {

         logger.info("CASE 7: INDIVIDUAL, INDIVIDUAL, INDIVIDUAL, CLUBBED, CLUBBED");
         aggregationLevel = "L3";

      } else if (geoL1.contains("INDIVIDUAL") && geoL2.contains("INDIVIDUAL") && geoL3.contains("INDIVIDUAL")
            && geoL4.contains("CLUBBED") && node.contains("INDIVIDUAL")) {

         logger.info("CASE 8: INDIVIDUAL, INDIVIDUAL, INDIVIDUAL, CLUBBED, INDIVIDUAL");
         aggregationLevel = "H1";

      } else if (geoL1.contains("INDIVIDUAL") && geoL2.contains("INDIVIDUAL") && geoL3.contains("INDIVIDUAL")
            && geoL4.contains("INDIVIDUAL") && node.contains("CLUBBED")) {

         logger.info("CASE 9: INDIVIDUAL, INDIVIDUAL, INDIVIDUAL, INDIVIDUAL, CLUBBED");
         aggregationLevel = "L4";

      } else if (geoL1.contains("INDIVIDUAL") && geoL2.contains("INDIVIDUAL") && geoL3.contains("INDIVIDUAL")
            && geoL4.contains("INDIVIDUAL") && node.contains("INDIVIDUAL")) {

         logger.info("CASE 10: INDIVIDUAL, INDIVIDUAL, INDIVIDUAL, INDIVIDUAL, CLUBBED");
         aggregationLevel = "H1";
      } else if (isGeoL1MultiSelect && geoL2.contains("CLUBBED") && geoL3.contains("CLUBBED")
            && geoL4.contains("CLUBBED") && node.contains("CLUBBED")) {

         logger.info("CASE 11: MULTI SELECT, CLUBBED, CLUBBED, CLUBBED, CLUBBED");
         aggregationLevel = "L1";

      } else if (isGeoL1MultiSelect && geoL2.contains("CLUBBED") && geoL3.contains("CLUBBED")
            && geoL4.contains("CLUBBED") && node.contains("INDIVIDUAL")) {

         logger.info("CASE 12: MULTI SELECT, CLUBBED, CLUBBED, CLUBBED, INDIVIDUAL");
         aggregationLevel = "H1";

      } else if (isGeoL1MultiSelect && geoL2.contains("INDIVIDUAL") && geoL3.contains("CLUBBED")
            && geoL4.contains("CLUBBED") && node.contains("CLUBBED")) {

         logger.info("CASE 13: MULTI SELECT, INDIVIDUAL, CLUBBED, CLUBBED, CLUBBED");
         aggregationLevel = "L2";

      } else if (isGeoL1MultiSelect && geoL2.contains("INDIVIDUAL") && geoL3.contains("CLUBBED")
            && geoL4.contains("CLUBBED") && node.contains("INDIVIDUAL")) {

         logger.info("CASE 14: MULTI SELECT, INDIVIDUAL, CLUBBED, CLUBBED, INDIVIDUAL");
         aggregationLevel = "H1";

      } else if (isGeoL1MultiSelect && geoL2.contains("INDIVIDUAL") && geoL3.contains("INDIVIDUAL")
            && geoL4.contains("CLUBBED") && node.contains("CLUBBED")) {

         logger.info("CASE 15: MULTI SELECT, INDIVIDUAL, INDIVIDUAL, CLUBBED, CLUBBED");
         aggregationLevel = "L3";

      } else if (isGeoL1MultiSelect && geoL2.contains("INDIVIDUAL") && geoL3.contains("INDIVIDUAL")
            && geoL4.contains("CLUBBED") && node.contains("INDIVIDUAL")) {

         logger.info("CASE 16: MULTI SELECT, INDIVIDUAL, INDIVIDUAL, CLUBBED, CLUBBED");
         aggregationLevel = "H1";

      } else if (isGeoL1MultiSelect && geoL2.contains("INDIVIDUAL") && geoL3.contains("INDIVIDUAL")
            && geoL4.contains("INDIVIDUAL") && node.contains("CLUBBED")) {

         logger.info("CASE 17: MULTI SELECT, INDIVIDUAL, INDIVIDUAL, INDIVIDUAL, CLUBBED");
         aggregationLevel = "L4";

      } else if (isGeoL1MultiSelect && geoL2.contains("INDIVIDUAL") && geoL3.contains("INDIVIDUAL")
            && geoL4.contains("INDIVIDUAL") && node.contains("INDIVIDUAL")) {

         logger.info("CASE 18: MULTI SELECT, INDIVIDUAL, INDIVIDUAL, INDIVIDUAL, CLUBBED");
         aggregationLevel = "H1";

      } else if (isGeoL1MultiSelect && isGeoL2MultiSelect && geoL3.contains("CLUBBED")
            && geoL4.contains("CLUBBED") && node.contains("CLUBBED")) {

         logger.info("CASE 19: MULTI SELECT, MULTI SELECT, CLUBBED, CLUBBED, CLUBBED");
         aggregationLevel = "L2";

      } else if (isGeoL1MultiSelect && isGeoL2MultiSelect && geoL3.contains("CLUBBED")
            && geoL4.contains("CLUBBED") && node.contains("INDIVIDUAL")) {

         logger.info("CASE 20: MULTI SELECT, MULTI SELECT, CLUBBED, CLUBBED, INDIVIDUAL");
         aggregationLevel = "H1";

      } else if (isGeoL1MultiSelect && isGeoL2MultiSelect && geoL3.contains("INDIVIDUAL")
            && geoL4.contains("CLUBBED") && node.contains("CLUBBED")) {

         logger.info("CASE 21: MULTI SELECT, MULTI SELECT, INDIVIDUAL, CLUBBED, CLUBBED");
         aggregationLevel = "L3";

      } else if (isGeoL1MultiSelect && isGeoL2MultiSelect && geoL3.contains("INDIVIDUAL")
            && geoL4.contains("CLUBBED") && node.contains("INDIVIDUAL")) {

         logger.info("CASE 22: MULTI SELECT, MULTI SELECT, INDIVIDUAL, CLUBBED, INDIVIDUAL");
         aggregationLevel = "H1";

      } else if (isGeoL1MultiSelect && isGeoL2MultiSelect && isGeoL3MultiSelect
            && geoL4.contains("CLUBBED") && node.contains("CLUBBED")) {

         logger.info("CASE 23: MULTI SELECT, MULTI SELECT, MULTI SELECT, CLUBBED, CLUBBED");
         aggregationLevel = "L3";

      } else if (isGeoL1MultiSelect && isGeoL2MultiSelect && isGeoL3MultiSelect
            && geoL4.contains("CLUBBED") && node.contains("INDIVIDUAL")) {

         logger.info("CASE 24: MULTI SELECT, MULTI SELECT, MULTI SELECT, CLUBBED, INDIVIDUAL");
         aggregationLevel = "H1";

      } else if (isGeoL1MultiSelect && isGeoL2MultiSelect && isGeoL3MultiSelect
            && geoL4.contains("INDIVIDUAL") && node.contains("CLUBBED")) {

         logger.info("CASE 25: MULTI SELECT, MULTI SELECT, MULTI SELECT, INDIVIDUAL, CLUBBED");
         aggregationLevel = "L4";

      } else if (isGeoL1MultiSelect && isGeoL2MultiSelect && isGeoL3MultiSelect
            && geoL4.contains("INDIVIDUAL") && node.contains("INDIVIDUAL")) {

         logger.info("CASE 26: MULTI SELECT, MULTI SELECT, MULTI SELECT, INDIVIDUAL, CLUBBED");
         aggregationLevel = "H1";

      } else if (isGeoL1MultiSelect && isGeoL2MultiSelect && isGeoL3MultiSelect && isGeoL4MultiSelect
            && node.contains("CLUBBED")) {

         logger.info("CASE 27: MULTI SELECT, MULTI SELECT, MULTI SELECT, MULTI SELECT, CLUBBED");
         aggregationLevel = "L4";

      } else if (isGeoL1MultiSelect && isGeoL2MultiSelect && isGeoL3MultiSelect && isGeoL4MultiSelect
            && node.contains("INDIVIDUAL")) {

         logger.info("CASE 28: MULTI SELECT, MULTI SELECT, MULTI SELECT, MULTI SELECT, INDIVIDUAL");
         aggregationLevel = "H1";

      } else if (isGeoL1MultiSelect && isGeoL2MultiSelect && geoL3.contains("INDIVIDUAL")
            && geoL4.contains("INDIVIDUAL") && node.contains("CLUBBED")) {

         logger.info("CASE 29: MULTI SELECT, MULTI SELECT, INDIVIDUAL, INDIVIDUAL, CLUBBED");
         aggregationLevel = "L4";

      } else if (isGeoL1MultiSelect && isGeoL2MultiSelect && geoL3.contains("INDIVIDUAL")
            && geoL4.contains("INDIVIDUAL") && node.contains("INDIVIDUAL")) {

         logger.info("CASE 30: MULTI SELECT, MULTI SELECT, INDIVIDUAL, INDIVIDUAL, INDIVIDUAL");
         aggregationLevel = "H1";

      } else {

         logger.info("=========This Case In Not Implemented==========");
         aggregationLevel = "H1";
      }

      return aggregationLevel;
   }

   private static String getTimeKeys(String fromDate, String toDate, JobContext jobContext) {

      // QuarterKey Format: 202501160000 (YYYYMMDDHHMM)

      DateTimeFormatter inputFormat = DateTimeFormatter.ofPattern("MMM dd,yyyy H:mm", Locale.ENGLISH);

      String frequency = jobContext.getParameter("FREQUENCY");
      logger.info("Getting Time Key, With From Date={}, To Date={}, Frequency={}", fromDate, toDate, frequency);

      DateTimeFormatter keyFormat = null;

      if ("15 Min".equalsIgnoreCase(frequency) ||
            "QUARTERLY".equalsIgnoreCase(frequency)) {
         keyFormat = DateTimeFormatter.ofPattern("yyyyMMddHHmm");
      } else if ("HOURLY".equalsIgnoreCase(frequency) ||
            "PERHOUR".equalsIgnoreCase(frequency)) {
         keyFormat = DateTimeFormatter.ofPattern("yyyyMMddHH");
      } else if ("DAILY".equalsIgnoreCase(frequency) ||
            "PERDAY".equalsIgnoreCase(frequency)) {
         keyFormat = DateTimeFormatter.ofPattern("yyyyMMdd");
      } else {
         keyFormat = DateTimeFormatter.ofPattern("yyyyMMdd");
      }

      LocalDateTime start = LocalDateTime.parse(fromDate, inputFormat);
      LocalDateTime end = LocalDateTime.parse(toDate, inputFormat);

      List<String> timeKeys = new ArrayList<>();
      while (!start.isAfter(end)) {
         timeKeys.add(start.format(keyFormat));
         if ("15 Min".equalsIgnoreCase(frequency) ||
               "QUARTERLY".equalsIgnoreCase(frequency)) {
            start = start.plusMinutes(15);
         } else if ("HOURLY".equalsIgnoreCase(frequency) ||
               "PERHOUR".equalsIgnoreCase(frequency)) {
            start = start.plusHours(1);
         } else if ("DAILY".equalsIgnoreCase(frequency) ||
               "PERDAY".equalsIgnoreCase(frequency)) {
            start = start.plusDays(1);
         } else {
            start = start.plusDays(1);
         }
      }

      return String.join(",", timeKeys);
   }

   private static Map<String, Map<String, String>> getKpiFormulaMap(String kpiCodesCommaSeparated,
         Map<String, String> reportWidgetDetailsMap, JobContext jobContext) {

      Map<String, Map<String, String>> kpiFormulaFinalMap = new LinkedHashMap<>();

      logger.info("Getting KPI Formula Map With KPI IDs={}", kpiCodesCommaSeparated);
      try {

         String kpiFormulaQuery = getKpiFormulaQuery(kpiCodesCommaSeparated, reportWidgetDetailsMap);
         ResultSet resultSet = getResultSet(kpiFormulaQuery, jobContext);

         while (resultSet.next()) {

            String kpiCodeFormula = resultSet.getString(1);
            String binaryValue = resultSet.getString(2);
            String uniqueString = resultSet.getString(3);

            String kpiCode = kpiCodeFormula.split("##")[0];
            String kpiDesc = kpiCodeFormula.split("##")[1];

            String key = kpiCode + "##" + kpiDesc;

            if (!kpiFormulaFinalMap.isEmpty() && kpiFormulaFinalMap.containsKey(key)) {
               Map<String, String> counterUniqueStringMap = kpiFormulaFinalMap.get(key);
               counterUniqueStringMap.put(binaryValue, uniqueString);
               kpiFormulaFinalMap.put(key, counterUniqueStringMap);
            } else {
               Map<String, String> counterUniqueStringMap = new LinkedHashMap<>();
               counterUniqueStringMap.put(binaryValue, uniqueString);
               kpiFormulaFinalMap.put(key, counterUniqueStringMap);
            }
         }

         return kpiFormulaFinalMap;

      } catch (Exception e) {
         logger.error("Exception While Fetching KPI Formula Map, Message={}, Error={}", e.getMessage(), e);
      }

      return kpiFormulaFinalMap;
   }

   private static String getKpiFormulaQuery(String kpiCodesCommaSeparated, Map<String, String> reportWidgetDetailsMap) {

      String kpiFormulaQuery = "SELECT DISTINCT CONCAT(kf.KPI_CODE, '##', kf.KPI_FORMULA_DESC) AS KPI_CODE_FORMULA, CAST(COALESCE(CONCAT('C', kc.SEQUENCE_NO, '#', pmc.PM_COUNTER_VARIABLE_ID_PK), 'null') AS BINARY) AS BINARY_VALUE, pmc.UNIQUE_STRING AS UNIQUE_STRING FROM KPI_FORMULA kf LEFT JOIN ( FORMULA_COUNTER_MAPPING fcm JOIN PM_COUNTER_VARIABLE pmc ON fcm.PM_COUNTER_VARIABLE_ID_FK = pmc.PM_COUNTER_VARIABLE_ID_PK ) ON fcm.KPI_FORMULA_ID_FK = kf.KPI_FORMULA_ID_PK LEFT JOIN GENERIC_KPI_MAPPING gkm ON kf.KPI_FORMULA_ID_PK = gkm.KPI_FORMULA_ID_FK LEFT JOIN PM_GENERIC_KPI gk ON gkm.PM_GENERIC_KPI_ID_FK = gk.PM_GENERIC_KPI_ID_PK LEFT JOIN KPI_COUNTER kc ON kc.KPI_COUNTER_ID_PK = pmc.KPI_COUNTER_ID_FK WHERE kf.DOMAIN = '$DOMAIN' AND kf.VENDOR = '$VENDOR' AND kf.KPI_CODE IN ($KPI_CODES) AND kf.DELETED = 0";

      kpiFormulaQuery = kpiFormulaQuery.replace("$DOMAIN", reportWidgetDetailsMap.get("DOMAIN"))
            .replace("$VENDOR", reportWidgetDetailsMap.get("VENDOR"))
            .replace("$KPI_CODES", kpiCodesCommaSeparated);

      return kpiFormulaQuery;

   }

   private void getPMCounterVariableAggrQuery(JobContext jobContext, String frequency, String timeKeysCommaSeparated)
         throws Exception {

      logger.info("Get PM Counter Variable Aggr Query, With Frequency={}", frequency);

      StringBuilder NODE_AGGREGATION_QUERY_BUILDER = new StringBuilder();
      StringBuilder COUNTER_WITH_NODE_AGGR_BUILDER = new StringBuilder();
      StringBuilder COUNTER_WITH_TIME_AGGR_BUILDER = new StringBuilder();
      StringBuilder FILTER_QUERY_BUILDER = new StringBuilder();

      StringBuilder mapQuery = new StringBuilder();
      String COUNTER_QUERY_MAP = null;

      Set<String> quarterKeys = Set.of("15 MIN", "QUARTERLY");
      Set<String> dateKeys = Set.of("DAILY", "PERDAY");
      Set<String> hourKeys = Set.of("HOURLY", "PERHOUR");

      String timeKey = "";
      String upperFreq = frequency.toUpperCase();
      if (quarterKeys.contains(upperFreq)) {
         timeKey = "quarterKey ";
      } else if (dateKeys.contains(upperFreq)) {
         timeKey = "dateKey ";
      } else if (hourKeys.contains(upperFreq)) {
         timeKey = "hourKey ";
      } else {
         timeKey = "dateKey ";
      }

      String CATEGORY_INFO_MAP_JSON = jobContext.getParameter("CATEGORY_INFO_MAP");
      @SuppressWarnings("unchecked")
      Map<String, List<Map<String, String>>> CATEGORY_INFO_MAP = new ObjectMapper().readValue(CATEGORY_INFO_MAP_JSON,
            Map.class);

      String CATEGORY_LIST = jobContext.getParameter("CATEGORY_LIST");

      logger.info("Category List={}", CATEGORY_LIST);
      logger.info("Category Info Map={}", CATEGORY_INFO_MAP);

      COUNTER_WITH_NODE_AGGR_BUILDER.append(
            " SELECT quarterKey, dateKey, hourKey, finalKey, categoryname, NAM, FIRST_VALUE(metaData) AS metaData, ");

      for (String category : CATEGORY_LIST.split(",")) {

         String categoryName = category.split("@")[0];
         List<Map<String, String>> CATEGORY_INFO_LIST = CATEGORY_INFO_MAP.get(category);
         if (CATEGORY_INFO_LIST == null) {
            continue;
         }

         for (Map<String, String> EACH_CATEGORY_INFO_MAP : CATEGORY_INFO_LIST) {

            String SEQUENCE_NO = EACH_CATEGORY_INFO_MAP.get("SEQUENCE_NO");
            String PM_COUNTER_VARIABLE_ID_PK = EACH_CATEGORY_INFO_MAP.get("PM_COUNTER_VARIABLE_ID_PK");
            String NODE_AGGREGATION = EACH_CATEGORY_INFO_MAP.get("NODE_AGGREGATION");
            String TIME_AGGREGATION = EACH_CATEGORY_INFO_MAP.get("TIME_AGGREGATION");

            String counterKey = "C" + SEQUENCE_NO + "#" + PM_COUNTER_VARIABLE_ID_PK;
            String counterId = counterKey.split("#")[1];
            String nodeAggrVal = NODE_AGGREGATION;
            String timeAggrVal = TIME_AGGREGATION;

            if (!nodeAggrVal.isEmpty() && !timeAggrVal.isEmpty()) {
               mapQuery.append("'").append(counterKey).append("', `").append(counterKey)
                     .append("`, '").append(counterId).append("', `").append(counterKey).append("`, ");
            }

            logger.info("Generated Map Query={}", mapQuery);

            String date = timeKeysCommaSeparated;

            if (!nodeAggrVal.isEmpty()) {
               if (nodeAggrVal.equalsIgnoreCase("AVG")) {
                  COUNTER_WITH_NODE_AGGR_BUILDER.append(nodeAggrVal).append("(CASE WHEN categoryname = '")
                        .append(categoryName)
                        .append("' AND ").append(timeKey).append(" IN ('").append(date.replace(",", "','"))
                        .append("') THEN CAST(`").append(counterKey).append("` AS DOUBLE)  ELSE NULL END) AS `")
                        .append(counterKey).append("`, sum(CASE WHEN categoryname = '").append(categoryName)
                        .append("' AND ").append(timeKey).append(" IN ('").append(date.replace(",", "','"))
                        .append("') THEN CAST(`").append(counterKey).append("` AS DOUBLE) ELSE NULL END) AS `S")
                        .append(counterKey).append("`, COUNT(CASE WHEN categoryname = '").append(categoryName)
                        .append("' AND ").append(timeKey).append(" IN ('").append(date.replace(",", "','"))
                        .append("') THEN CAST(`").append(counterKey).append("` AS DOUBLE) ELSE NULL END) AS `C")
                        .append(counterKey).append("`, ");

                  NODE_AGGREGATION_QUERY_BUILDER.append("sum(`S").append(counterKey).append("`)/sum(`C")
                        .append(counterKey)
                        .append("`) AS `").append(counterKey).append("`, sum(`S").append(counterKey)
                        .append("`) AS `S").append(counterKey).append("`, sum(`C").append(counterKey)
                        .append("`) AS `C").append(counterKey).append("`, ");

                  FILTER_QUERY_BUILDER.append("(`S").append(counterKey).append("`) AS `S").append(counterKey)
                        .append("`, (`C").append(counterKey).append("`) AS `C").append(counterKey).append("`,");
               } else {
                  COUNTER_WITH_NODE_AGGR_BUILDER.append(nodeAggrVal).append("(CASE WHEN categoryname = '")
                        .append(categoryName)
                        .append("' AND ").append(timeKey).append(" IN ('").append(date.replace(",", "','"))
                        .append("') THEN CAST(`").append(counterKey).append("` AS DOUBLE) ELSE NULL END) AS `")
                        .append(counterKey).append("`, ");

                  NODE_AGGREGATION_QUERY_BUILDER.append(nodeAggrVal).append("(`").append(counterKey)
                        .append("`) AS `")
                        .append(counterKey).append("`, ");

                  FILTER_QUERY_BUILDER.append("(`").append(counterKey).append("`) AS `").append(counterKey)
                        .append("`, ");
               }
            }

            if (!timeAggrVal.isEmpty()) {
               COUNTER_WITH_TIME_AGGR_BUILDER.append(timeAggrVal).append("(`").append(counterKey).append("`) AS `")
                     .append(counterKey).append("`,");
            }
         }
      }

      logger.info("‚û°Ô∏è   COUNTER_WITH_NODE_AGGR_BUILDER={}", COUNTER_WITH_NODE_AGGR_BUILDER);
      logger.info("‚û°Ô∏è   COUNTER_WITH_TIME_AGGR_BUILDER={}", COUNTER_WITH_TIME_AGGR_BUILDER);
      logger.info("‚û°Ô∏è   NODE_AGGREGATION_QUERY_BUILDER={}", NODE_AGGREGATION_QUERY_BUILDER);
      logger.info("‚û°Ô∏è   FILTER_QUERY_BUILDER={}", FILTER_QUERY_BUILDER);
      logger.info("‚û°Ô∏è   MAP_QUERY={}", mapQuery);

      String mapQueryStr = mapQuery.toString();
      int lastCommaIndex = mapQueryStr.lastIndexOf(",");
      COUNTER_QUERY_MAP = (lastCommaIndex != -1 ? mapQueryStr.substring(0, lastCommaIndex) : mapQueryStr);
      COUNTER_QUERY_MAP = "Map(" + COUNTER_QUERY_MAP + ") AS rawcounters";

      String COUNTER_WITH_NODE_AGGR = COUNTER_WITH_NODE_AGGR_BUILDER.toString();
      String COUNTER_WITH_TIME_AGGR = COUNTER_WITH_TIME_AGGR_BUILDER.toString();
      String NODE_AGGREGATION_QUERY = NODE_AGGREGATION_QUERY_BUILDER.toString();
      String FILTER_QUERY = FILTER_QUERY_BUILDER.toString();

      COUNTER_WITH_NODE_AGGR = COUNTER_WITH_NODE_AGGR.trim().endsWith(",")
            ? COUNTER_WITH_NODE_AGGR.trim().substring(0, COUNTER_WITH_NODE_AGGR.trim().length() - 1)
            : COUNTER_WITH_NODE_AGGR;
      COUNTER_WITH_TIME_AGGR = COUNTER_WITH_TIME_AGGR.trim().endsWith(",")
            ? COUNTER_WITH_TIME_AGGR.trim().substring(0, COUNTER_WITH_TIME_AGGR.trim().length() - 1)
            : COUNTER_WITH_TIME_AGGR;
      NODE_AGGREGATION_QUERY = NODE_AGGREGATION_QUERY.trim().endsWith(",")
            ? NODE_AGGREGATION_QUERY.trim().substring(0, NODE_AGGREGATION_QUERY.trim().length() - 1)
            : NODE_AGGREGATION_QUERY;
      FILTER_QUERY = FILTER_QUERY.trim().endsWith(",")
            ? FILTER_QUERY.trim().substring(0, FILTER_QUERY.trim().length() - 1)
            : FILTER_QUERY;

      String COUNTER_NODE_AGGR_QUERY = "SELECT finalKey, FIRST_VALUE(metaData) AS metaData, " + NODE_AGGREGATION_QUERY
            + " FROM FinalCounterData GROUP BY finalKey";

      String FILTER_QUERY_FINAL = FILTER_QUERY;

      String RAW_FILE_COUNTER_NODE_AGGR_QUERY = COUNTER_WITH_NODE_AGGR
            + " FROM JOINED_RESULT GROUP BY quarterKey, finalKey, dateKey, hourKey, NAM, categoryname";

      String COUNTER_TIME_AGGR_QUERY = "SELECT finalKey, FIRST_VALUE(metaData) AS metaData, " + COUNTER_WITH_TIME_AGGR
            + " FROM finalNodeAggrData GROUP BY finalKey ORDER BY finalKey";

      jobContext.setParameters("COUNTER_MAP_QUERY", COUNTER_QUERY_MAP);
      jobContext.setParameters("FILTER_QUERY_FINAL", FILTER_QUERY_FINAL);
      jobContext.setParameters("COUNTER_NODE_AGGR_QUERY", COUNTER_NODE_AGGR_QUERY);
      jobContext.setParameters("COUNTER_TIME_AGGR_QUERY", COUNTER_TIME_AGGR_QUERY);
      jobContext.setParameters("RAW_FILE_COUNTER_NODE_AGGR_QUERY", RAW_FILE_COUNTER_NODE_AGGR_QUERY);

      logger.info("üöÄ COUNTER_MAP_QUERY={}", COUNTER_QUERY_MAP);
      logger.info("üöÄ FILTER_QUERY_FINAL={}", FILTER_QUERY_FINAL);
      logger.info("üöÄ COUNTER_NODE_AGGR_QUERY={}", COUNTER_NODE_AGGR_QUERY);
      logger.info("üöÄ COUNTER_TIME_AGGR_QUERY={}", COUNTER_TIME_AGGR_QUERY);
      logger.info("üöÄ RAW_FILE_COUNTER_NODE_AGGR_QUERY={}", RAW_FILE_COUNTER_NODE_AGGR_QUERY);
   }

   private static Map<String, List<Map<String, String>>> getCatgoryInfoMap(
         Map<String, Map<String, String>> counterInfoMap) {
      Map<String, List<Map<String, String>>> catgoryInfoMap = new LinkedHashMap<>();

      for (Map<String, String> value : counterInfoMap.values()) {

         List<Map<String, String>> infoMapList = catgoryInfoMap.get(value.get("CATEGORY_NAME"));
         if (infoMapList == null) {
            infoMapList = new ArrayList<>();
         }
         Map<String, String> infoMap = new LinkedHashMap<>();
         infoMap.put("SEQUENCE_NO", value.get("SEQUENCE_NO"));
         infoMap.put("COUNTER_HEADER_NAME", value.get("COUNTER_HEADER_NAME"));
         infoMap.put("PM_COUNTER_VARIABLE_ID_PK", value.get("PM_COUNTER_VARIABLE_ID_PK"));
         infoMap.put("UNIQUE_STRING", value.get("UNIQUE_STRING"));
         infoMap.put("NODE_AGGREGATION", value.get("NODE_AGGREGATION"));
         infoMap.put("TIME_AGGREGATION", value.get("TIME_AGGREGATION"));

         // SUB_CATEGORY_HEADER1

         if (value.get("SUB_CATEGORY_HEADER1") != null && !value.get("SUB_CATEGORY_HEADER1").isEmpty()
               && !value.get("SUB_CATEGORY_HEADER1").equalsIgnoreCase("null")) {

            infoMap.put("SUB_CATEGORY_HEADER1", value.get("SUB_CATEGORY_HEADER1"));
            infoMap.put("SUB_CATEGORY_VALUE1", value.get("SUB_CATEGORY_VALUE1"));
         }

         // SUB_CATEGORY_HEADER2

         if (value.get("SUB_CATEGORY_HEADER2") != null && !value.get("SUB_CATEGORY_HEADER2").isEmpty()
               && !value.get("SUB_CATEGORY_HEADER2").equalsIgnoreCase("null")) {

            infoMap.put("SUB_CATEGORY_HEADER2", value.get("SUB_CATEGORY_HEADER2"));
            infoMap.put("SUB_CATEGORY_VALUE2", value.get("SUB_CATEGORY_VALUE2"));
         }

         // SUB_CATEGORY_HEADER3

         if (value.get("SUB_CATEGORY_HEADER3") != null && !value.get("SUB_CATEGORY_HEADER3").isEmpty()
               && !value.get("SUB_CATEGORY_HEADER3").equalsIgnoreCase("null")) {

            infoMap.put("SUB_CATEGORY_HEADER3", value.get("SUB_CATEGORY_HEADER3"));
            infoMap.put("SUB_CATEGORY_VALUE3", value.get("SUB_CATEGORY_VALUE3"));
         }

         // SUB_CATEGORY_HEADER4

         if (value.get("SUB_CATEGORY_HEADER4") != null && !value.get("SUB_CATEGORY_HEADER4").isEmpty()
               && !value.get("SUB_CATEGORY_HEADER4").equalsIgnoreCase("null")) {

            infoMap.put("SUB_CATEGORY_HEADER4", value.get("SUB_CATEGORY_HEADER4"));
            infoMap.put("SUB_CATEGORY_VALUE4", value.get("SUB_CATEGORY_VALUE4"));
         }

         infoMapList.add(infoMap);
         catgoryInfoMap.put(value.get("CATEGORY_NAME"), infoMapList);
      }
      return catgoryInfoMap;
   }

   public static Map<String, Map<String, String>> getCounterInfoMap(JobContext jobContext,
         Map<String, String> reportWidgetDetailsMap, String commaSeparatedKpiCodes) throws SQLException {

      Map<String, Map<String, String>> counterInfoMap = new LinkedHashMap<>();

      String counterInfoMapQuery = getCounterInfoMapQuery(jobContext, reportWidgetDetailsMap, commaSeparatedKpiCodes);

      ResultSet resultSet = getResultSet(counterInfoMapQuery, jobContext);

      if (resultSet == null) {
         throw new SQLException("No Data Found in Counter Info Map Query Result Set!");
      }

      counterInfoMap = getCounterInfoMapFromResultSet(resultSet);

      return counterInfoMap;
   }

   private static Map<String, Map<String, String>> getCounterInfoMapFromResultSet(ResultSet resultSet)
         throws SQLException {
      Map<String, Map<String, String>> counterInfoMap = new LinkedHashMap<>();

      while (resultSet.next()) {
         String COUNTER_HEADER_NAME = resultSet.getString(1);
         String PM_COUNTER_VARIABLE_ID_PK = resultSet.getString(2);
         String CATEGORY_NAME = resultSet.getString(3) + "@" + resultSet.getString(14);
         String SUBCATEGORY1_VALUE = resultSet.getString(5);
         String SUBCATEGORY2_VALUE = resultSet.getString(6);
         String SUBCATEGORY3_VALUE = resultSet.getString(7);
         String SUBCATEGORY4_VALUE = resultSet.getString(8);
         String SUBCAT_HEADER1 = resultSet.getString(9);
         String SUBCAT_HEADER2 = resultSet.getString(10);
         String SUBCAT_HEADER3 = resultSet.getString(11);
         String SUBCAT_HEADER4 = resultSet.getString(12);
         String SEQUENCE_NO = resultSet.getString(13);
         String UNIQUE_STRING = resultSet.getString(15);
         String NODE_AGGREGATION = resultSet.getString(16);
         String TIME_AGGREGATION = resultSet.getString(17);

         Map<String, String> infoMap = counterInfoMap.get(COUNTER_HEADER_NAME);
         if (infoMap == null) {
            infoMap = new LinkedHashMap<>();
         }
         infoMap.put("COUNTER_HEADER_NAME", COUNTER_HEADER_NAME);
         infoMap.put("PM_COUNTER_VARIABLE_ID_PK", PM_COUNTER_VARIABLE_ID_PK);
         infoMap.put("CATEGORY_NAME", CATEGORY_NAME);
         infoMap.put("SEQUENCE_NO", SEQUENCE_NO);
         infoMap.put("UNIQUE_STRING", UNIQUE_STRING);
         infoMap.put("NODE_AGGREGATION", NODE_AGGREGATION);
         infoMap.put("TIME_AGGREGATION", TIME_AGGREGATION);
         prepareinfoMap(SUBCATEGORY1_VALUE, SUBCAT_HEADER1, infoMap, "SUB_CATEGORY_HEADER1", "SUB_CATEGORY_VALUE1");
         prepareinfoMap(SUBCATEGORY2_VALUE, SUBCAT_HEADER2, infoMap, "SUB_CATEGORY_HEADER2", "SUB_CATEGORY_VALUE2");
         prepareinfoMap(SUBCATEGORY3_VALUE, SUBCAT_HEADER3, infoMap, "SUB_CATEGORY_HEADER3", "SUB_CATEGORY_VALUE3");
         prepareinfoMap(SUBCATEGORY4_VALUE, SUBCAT_HEADER4, infoMap, "SUB_CATEGORY_HEADER4", "SUB_CATEGORY_VALUE4");

         String COUNTER_INFO_MAP_KEY = "C" + SEQUENCE_NO + "#" + PM_COUNTER_VARIABLE_ID_PK;
         counterInfoMap.put(COUNTER_INFO_MAP_KEY, infoMap);
      }
      return counterInfoMap;
   }

   private static void prepareinfoMap(String subCategoryValue, String subCategoryHeader, Map<String, String> infoMap,
         String headerColumn, String valueColumn) {
      if (subCategoryValue != null && !subCategoryValue.equalsIgnoreCase("null")
            && !subCategoryValue.contains("INDIVIDUAL") && !subCategoryValue.contains("AGGREGATED")) {
         infoMap.put(headerColumn, subCategoryHeader);
         if (infoMap.get(valueColumn) != null && !infoMap.get(valueColumn).equalsIgnoreCase("null")) {
            subCategoryValue = infoMap.get(valueColumn) + "','" + subCategoryValue;
            infoMap.put(valueColumn, subCategoryValue);
         } else {
            infoMap.put(valueColumn, subCategoryValue);
         }
      }
   }

   private static String getCounterInfoMapQuery(JobContext jobContext, Map<String, String> reportWidgetDetailsMap,
         String commaSeparatedKpiCodes) {

      String counterInfoMapQuery = "SELECT DISTINCT UPPER(REPLACE(cv.COUNTER, ' ', '')) AS COUNTER_HEADER_NAME, cv.PM_COUNTER_VARIABLE_ID_PK AS PM_COUNTER_VARIABLE_ID_PK, UPPER(REPLACE(kc.CATEGORY_ALIAS_NAME, ' ', '')) AS CATEGORY_NAME, cv.ATTRIBUTE AS ATTRIBUTE, cv.SUBCATEGORY1_VALUE AS SUBCATEGORY1_VALUE, cv.SUBCATEGORY2_VALUE AS SUBCATEGORY2_VALUE, cv.SUBCATEGORY3_VALUE AS SUBCATEGORY3_VALUE, cv.SUBCATEGORY4_VALUE AS SUBCATEGORY4_VALUE, CONCAT('C', subcat1.SEQUENCE_NO) AS SUBCAT_HEADER1, CONCAT('C', subcat2.SEQUENCE_NO) AS SUBCAT_HEADER2, CONCAT('C', subcat3.SEQUENCE_NO) AS SUBCAT_HEADER3, CONCAT('C', subcat4.SEQUENCE_NO) AS SUBCAT_HEADER4, kc.SEQUENCE_NO, UPPER(REPLACE(pc.PM_CATEGORY_ID_PK, ' ', '')) AS CATEGORY_ID, cv.UNIQUE_STRING, cv.NODE_AGGREGATION AS NODE_AGGREGATION, cv.TIME_AGGREGATION AS TIME_AGGREGATION FROM KPI_FORMULA kpi INNER JOIN FORMULA_COUNTER_MAPPING map ON kpi.KPI_FORMULA_ID_PK = map.KPI_FORMULA_ID_FK INNER JOIN PM_COUNTER_VARIABLE cv ON cv.PM_COUNTER_VARIABLE_ID_PK = map.PM_COUNTER_VARIABLE_ID_FK INNER JOIN KPI_COUNTER kc ON UPPER(kc.KPI_COUNTER_ID_PK) = UPPER(cv.KPI_COUNTER_ID_FK) INNER JOIN PM_CATEGORY pc ON pc.PM_CATEGORY_ID_PK = cv.PM_CATEGORY_ID_FK LEFT JOIN KPI_COUNTER subcat1 ON subcat1.KPI_COUNTER_ID_PK = cv.KPI_COUNTER1_ID_FK LEFT JOIN KPI_COUNTER subcat2 ON subcat2.KPI_COUNTER_ID_PK = cv.KPI_COUNTER2_ID_FK LEFT JOIN KPI_COUNTER subcat3 ON subcat3.KPI_COUNTER_ID_PK = cv.KPI_COUNTER3_ID_FK LEFT JOIN KPI_COUNTER subcat4 ON subcat4.KPI_COUNTER_ID_PK = cv.KPI_COUNTER4_ID_FK WHERE kpi.DOMAIN = '$DOMAIN' AND kpi.VENDOR = '$VENDOR' AND kpi.TECHNOLOGY = '$TECHNOLOGY' AND kpi.KPI_CODE IN ($KPI_CODES)";

      counterInfoMapQuery = counterInfoMapQuery.replace("$DOMAIN", reportWidgetDetailsMap.get("DOMAIN"))
            .replace("$VENDOR", reportWidgetDetailsMap.get("VENDOR"))
            .replace("$TECHNOLOGY", reportWidgetDetailsMap.get("TECHNOLOGY"))
            .replace("$KPI_CODES", commaSeparatedKpiCodes);

      return counterInfoMapQuery;
   }

   private static Map<String, String> getMetaColumnsMap(Map<String, String> extraParametersMap) {

      String metaColumns = extraParametersMap.get("META_COLUMNS");
      if (metaColumns == null || metaColumns.isEmpty()) {
         return Collections.emptyMap();
      }

      Map<String, String> metaColumnsMap = new LinkedHashMap<>();
      String[] metaColumnsArray = metaColumns.split("#");
      String str1 = metaColumnsArray[0];
      String str2 = metaColumnsArray[1];
      String[] str1Array = str1.split(",");
      String[] str2Array = str2.split(",");

      for (int i = 0; i < str1Array.length; i++) {
         metaColumnsMap.put(str1Array[i].toUpperCase().trim(), str2Array[i].toUpperCase().trim());
      }

      return metaColumnsMap;
   }

   private static void initializeKPICounterDetails(Map<String, String> reportWidgetDetails,
         Map<String, String> kpiDetailsMap,
         Map<String, String> counterDetailsMap, List<String> kpiCodeList, List<String> counterIdList,
         Map<String, String> kpiCodeWithKpiNameMap, Map<String, String> counterIdWithCounterNameMap) {

      String configuration = reportWidgetDetails.get("CONFIGURATION");
      if (configuration == null || configuration.isEmpty()) {
         return;
      }

      String fixedJson = configuration.replace("'", "\"");
      JSONObject jsonObject = new JSONObject(fixedJson);

      try {
         JSONArray kpiArray = jsonObject.getJSONArray("kpi");

         for (int i = 0; i < kpiArray.length(); i++) {
            JSONObject kpiObject = kpiArray.getJSONObject(i);

            String type = kpiObject.optString("type", "").toUpperCase();

            if (type.equals("KPI")) {

               String kpiCode = kpiObject.optString("kpicode", "").toUpperCase().trim();
               String kpiName = kpiObject.optString("kpiName", "").toUpperCase().trim();
               String headerName = kpiObject.optString("headerName", "").toUpperCase().trim();

               String value = "KPI_CODE=" + kpiCode + "##" + "KPI_NAME=" + kpiName + "##" + "HEADER_NAME=" + headerName;
               kpiCodeList.add(kpiCode);
               kpiCodeWithKpiNameMap.put(kpiCode, kpiName);
               kpiDetailsMap.put(kpiCode, value);

            } else if (type.equals("COUNTER")) {

               String kpiName = kpiObject.optString("kpiName", "").toUpperCase().trim();
               String headerName = kpiObject.optString("headerName", "").toUpperCase().trim();
               String nodeAggregation = kpiObject.optString("nodeAggregation", "").toUpperCase().trim();
               String timeAggregation = kpiObject.optString("timeAggregation", "").toUpperCase().trim();
               String sequenceNo = kpiObject.optString("sequenceNo", "").toUpperCase();
               String kpigroup = kpiObject.optString("kpigroup", "").toUpperCase();
               String id = kpiObject.optString("id", "").toUpperCase();
               String categoryId = kpiObject.optString("categoryId", "").toUpperCase();

               String value = "COUNTER_NAME=" + kpiName + "##" + "HEADER_NAME=" + headerName + "##"
                     + "NODE_AGGREGATION=" + nodeAggregation + "##" + "TIME_AGGREGATION=" + timeAggregation + "##"
                     + "SEQUENCE_NO=" + sequenceNo + "##" + "KPI_GROUP=" + kpigroup + "##"
                     + "PM_COUNTER_VARIABLE_ID_PK=" + id + "##" + "PM_CATEGORY_ID_PK=" + categoryId;

               counterIdList.add(id);
               counterIdWithCounterNameMap.put(id, kpiName);
               counterDetailsMap.put(id, value);

            }

         }

      } catch (Exception e) {
         System.out.println("Error in Extracting KPI List, Message: " + e.getMessage() + ", Error: " + e);
      }

   }

   private static Map<String, String> getExtraParameters(Map<String, String> reportWidgetDetails,
         JobContext jobContext) {

      Map<String, String> extraParameters = new LinkedHashMap<>();

      try {

         String fixedJson = reportWidgetDetails.get("CONFIGURATION").replace("'", "\"");
         JSONObject jsonObject = new JSONObject(fixedJson);

         String metaColumns = jsonObject.optString("metaColumns", "");
         String reportFormatType = jsonObject.optString("reportFormatType", "");
         String toDate = jsonObject.optString("toDate", "");
         String fromDate = jsonObject.optString("fromDate", "");
         String kpiExpression = jsonObject.optString("kpiExpression", "");
         String startTime = convertToExpectedTimeStampFormat(toDate);
         String endTime = convertToExpectedTimeStampFormat(fromDate);

         extraParameters.put("META_COLUMNS", metaColumns);
         extraParameters.put("REPORT_FORMAT_TYPE", reportFormatType);
         extraParameters.put("TO_DATE", toDate);
         extraParameters.put("FROM_DATE", fromDate);
         extraParameters.put("START_TIME", startTime);
         extraParameters.put("END_TIME", endTime);
         extraParameters.put("KPI_EXPRESSION", kpiExpression);

         jobContext.setParameters("FROM_DATE", fromDate);
         jobContext.setParameters("TO_DATE", toDate);

         String isSpecificDate = "false";
         JSONArray specificDate = jsonObject.getJSONArray("specificDate");
         if (specificDate.length() > 0) {
            isSpecificDate = "true";
         }
         extraParameters.put("IS_SPECIFIC_DATE", isSpecificDate);

         if (isSpecificDate.equals("true")) {

            List<Long> specificDateList = new ArrayList<>();

            logger.info("Specific Date Found, Processing Specific Date List!");

            for (int i = 0; i < specificDate.length(); i++) {
               specificDateList.add(specificDate.getLong(i));
            }

            String dateList = specificDateList.stream()
                  .map(String::valueOf)
                  .collect(Collectors.joining(","));

            logger.info("Formatted Date List: {}", dateList);

            extraParameters.put("DATE_LIST", dateList);

         } else {
            logger.info("No Specific Date Found, Using Default Date Range!");
         }

      } catch (Exception e) {
         logger.error("Error in Getting CQL Parameters, Message: {}, Error: {}", e.getMessage(), e);

      }
      return extraParameters;
   }

   private static String getTrinoOrcFilePaths(Map<String, String> extraParametersMap,
         Map<String, String> reportWidgetDetails, JobContext jobContext) {

      String isSpecificDate = extraParametersMap.get("IS_SPECIFIC_DATE");
      if (isSpecificDate != null && isSpecificDate.equals("true")) {
         logger.info("üìä Specific Date Found, Need to Generate Trino ORC File Paths [Not Implemented Yet]!");
         return "";
      }

      String trinoOrcBasePath = jobContext.getParameters().get("BASE_TRINO_ORC_PATH");
      if (trinoOrcBasePath == null || trinoOrcBasePath.isEmpty()) {
         trinoOrcBasePath = "s3a://performance/JOB/ORC/QUARTERLY/";
      }

      String fromDate = extraParametersMap.get("FROM_DATE");
      String toDate = extraParametersMap.get("TO_DATE");

      logger.info("üìä Trino ORC Base Path: {}", trinoOrcBasePath);
      logger.info("üìä From Date: {}", fromDate);
      logger.info("üìä To Date: {}", toDate);

      // Extract path parameters from report widget details with fallback defaults
      String domain = reportWidgetDetails.getOrDefault("DOMAIN", "NA");
      String vendor = reportWidgetDetails.getOrDefault("VENDOR", "NA");
      String emstype = reportWidgetDetails.getOrDefault("EMSTYPE", "NA");
      String technology = reportWidgetDetails.getOrDefault("TECHNOLOGY", "NA");

      DateTimeFormatter inputFormat = DateTimeFormatter.ofPattern("MMM dd,yyyy H:mm", Locale.ENGLISH);
      DateTimeFormatter folderDateFormat = DateTimeFormatter.ofPattern("yyMMdd");
      DateTimeFormatter timeFormat = DateTimeFormatter.ofPattern("HHmm");

      LocalDateTime start = LocalDateTime.parse(fromDate, inputFormat);
      LocalDateTime end = LocalDateTime.parse(toDate, inputFormat);

      List<String> pathList = new ArrayList<>();

      while (!start.isAfter(end)) {
         String dateStr = start.format(folderDateFormat); // e.g., 250118
         String timeStr = start.format(timeFormat); // e.g., 0000

         String fullPath = String.format(
               "%sdomain=%s/vendor=%s/emstype=%s/technology=%s/date=%s/time=%s/ptime=*/categoryname=*/",
               trinoOrcBasePath, domain, vendor, emstype, technology, dateStr, timeStr);

         pathList.add(fullPath);
         start = start.plusMinutes(15);
      }

      logger.info("üìä Trino ORC File Path List Size: {}", pathList.size());

      return String.join(",", pathList);
   }

   private static String convertToExpectedTimeStampFormat(String date) {
      try {
         DateTimeFormatter inputFormatter = DateTimeFormatter.ofPattern("MMM d,yyyy H:mm");
         DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSSSSSxx");
         LocalDateTime localDateTime = LocalDateTime.parse(date, inputFormatter);
         return localDateTime.atOffset(ZoneOffset.UTC).format(outputFormatter);
      } catch (Exception e) {
         LocalDateTime now = LocalDateTime.now(ZoneOffset.UTC);
         DateTimeFormatter outputFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSSSSSxx");
         return now.atOffset(ZoneOffset.UTC).format(outputFormatter);
      }
   }

   private static Map<String, String> getNodeAndAggregationDetails(Map<String, String> reportWidgetDetails,
         JobContext jobContext) {

      Map<String, String> nodeAndAggregationDetails = new LinkedHashMap<>();

      try {
         String fixedJson = reportWidgetDetails.get("CONFIGURATION").replace("'", "\"");
         JSONObject jsonObject = new JSONObject(fixedJson);

         JSONArray geoL1JSONArray = jsonObject.getJSONArray("geography_l1");
         JSONArray geoL2JSONArray = jsonObject.getJSONArray("geography_l2");
         JSONArray geoL3JSONArray = jsonObject.getJSONArray("geography_l3");
         JSONArray geoL4JSONArray = jsonObject.getJSONArray("geography_l4");
         JSONArray nodeArray = jsonObject.getJSONArray("node");

         List<String> geoL1List = getStringListFromArray(geoL1JSONArray);
         List<String> geoL2List = getStringListFromArray(geoL2JSONArray);
         List<String> geoL3List = getStringListFromArray(geoL3JSONArray);
         List<String> geoL4List = getStringListFromArray(geoL4JSONArray);
         List<String> nodeList = getStringListFromArray(nodeArray);

         String geoL1 = geoL1List.get(0) != null && !geoL1List.get(0).isEmpty() ? geoL1List.get(0).toUpperCase()
               : "";
         String geoL2 = geoL2List.get(0) != null && !geoL2List.get(0).isEmpty() ? geoL2List.get(0).toUpperCase()
               : "";
         String geoL3 = geoL3List.get(0) != null && !geoL3List.get(0).isEmpty() ? geoL3List.get(0).toUpperCase()
               : "";
         String geoL4 = geoL4List.get(0) != null && !geoL4List.get(0).isEmpty() ? geoL4List.get(0).toUpperCase()
               : "";
         String node = nodeList.get(0) != null && !nodeList.get(0).isEmpty() ? nodeList.get(0).toUpperCase() : "";

         String netype = jsonObject.getString("netype");
         netype = netype != null && !netype.isEmpty() ? netype.toUpperCase() : "";

         logger.info("Provided Node & Aggragtaion Details: geoL1={}, geoL2={}, geoL3={}, geoL4={}, node={}",
               geoL1, geoL2, geoL3, geoL4, node);

         nodeAndAggregationDetails.put("GEOGRAPHY_L1", geoL1);
         nodeAndAggregationDetails.put("GEOGRAPHY_L2", geoL2);
         nodeAndAggregationDetails.put("GEOGRAPHY_L3", geoL3);
         nodeAndAggregationDetails.put("GEOGRAPHY_L4", geoL4);
         nodeAndAggregationDetails.put("NODE", node);
         nodeAndAggregationDetails.put("NETYPE", netype);
         nodeAndAggregationDetails.put("GEOGRAPHY_L1_LIST", geoL1List.toString());
         nodeAndAggregationDetails.put("GEOGRAPHY_L2_LIST", geoL2List.toString());
         nodeAndAggregationDetails.put("GEOGRAPHY_L3_LIST", geoL3List.toString());
         nodeAndAggregationDetails.put("GEOGRAPHY_L4_LIST", geoL4List.toString());
         nodeAndAggregationDetails.put("NODE_LIST", nodeList.toString());

         String isGeoL1MultiSelect = !geoL1.contains("CLUBBED") && !geoL1.contains("INDIVIDUAL") ? "true" : "false";
         String isGeoL2MultiSelect = !geoL2.contains("CLUBBED") && !geoL2.contains("INDIVIDUAL") ? "true" : "false";
         String isGeoL3MultiSelect = !geoL3.contains("CLUBBED") && !geoL3.contains("INDIVIDUAL") ? "true" : "false";
         String isGeoL4MultiSelect = !geoL4.contains("CLUBBED") && !geoL4.contains("INDIVIDUAL") ? "true" : "false";
         String isNodeMultiSelect = !node.contains("CLUBBED") && !node.contains("INDIVIDUAL") ? "true" : "false";

         nodeAndAggregationDetails.put("IS_GEOGRAPHY_L1_MULTI_SELECT", isGeoL1MultiSelect);
         nodeAndAggregationDetails.put("IS_GEOGRAPHY_L2_MULTI_SELECT", isGeoL2MultiSelect);
         nodeAndAggregationDetails.put("IS_GEOGRAPHY_L3_MULTI_SELECT", isGeoL3MultiSelect);
         nodeAndAggregationDetails.put("IS_GEOGRAPHY_L4_MULTI_SELECT", isGeoL4MultiSelect);
         nodeAndAggregationDetails.put("IS_NODE_MULTI_SELECT", isNodeMultiSelect);

         JSONArray nodeNameArray = jsonObject.getJSONArray("cells");
         List<String> nodeNameList = getStringListFromArray(nodeNameArray);
         String isNodeNameListEmpty = nodeNameList.isEmpty() ? "true" : "false";
         nodeAndAggregationDetails.put("IS_NODE_NAME_LIST_EMPTY", isNodeNameListEmpty);

         Map<String, String> nodeInfoMap = new LinkedHashMap<>();
         if (isNodeNameListEmpty.equals("false")) {
            nodeInfoMap = getNodeInfoMap(nodeNameList, reportWidgetDetails, jobContext);
            String nodeInfoMapJson = new ObjectMapper().writeValueAsString(nodeInfoMap);
            nodeAndAggregationDetails.put("NODE_INFO_MAP", nodeInfoMapJson);
         }

      } catch (Exception e) {
         logger.error("Error in getting Node and Aggregation Details, Message: {}, Error: {}", e.getMessage(), e);
      }

      return nodeAndAggregationDetails;

   }

   private static Map<String, String> getNodeInfoMap(List<String> nodeNameList,
         Map<String, String> reportWidgetDetails, JobContext jobContext) {
      Map<String, String> nodeInfoMap = new LinkedHashMap<>();
      ResultSet resultSet = getNodeInfoResultSet(nodeNameList, reportWidgetDetails, jobContext);
      try {
         while (resultSet.next()) {
            String neId = resultSet.getString("NE_ID");
            String neName = resultSet.getString("NE_NAME");
            nodeInfoMap.put(neId, neName);
         }
      } catch (Exception e) {
         logger.error("Error in getting Node Info Map, Message: {}, Error: {}", e.getMessage(), e);
      }
      return nodeInfoMap;
   }

   private static ResultSet getNodeInfoResultSet(List<String> nodeNameList, Map<String, String> reportWidgetDetails,
         JobContext jobContext) {

      String domain = reportWidgetDetails.get("DOMAIN");
      String vendor = reportWidgetDetails.get("VENDOR");
      String technology = reportWidgetDetails.get("TECHNOLOGY");

      domain = domain != null && !domain.isEmpty() ? domain.toUpperCase() : "N/A";
      vendor = vendor != null && !vendor.isEmpty() ? vendor.toUpperCase() : "N/A";
      technology = technology != null && !technology.isEmpty() ? technology.toUpperCase() : "N/A";

      List<String> quotedNodeNames = nodeNameList.stream()
            .map(name -> "'" + name.trim() + "'")
            .collect(Collectors.toList());

      String query = "SELECT NE_ID, NE_NAME FROM NETWORK_ELEMENT WHERE DOMAIN = '" + domain + "' AND VENDOR = '"
            + vendor
            + "' AND TECHNOLOGY = '" + technology + "' AND NE_NAME IN (" + String.join(",", quotedNodeNames) + ")";

      logger.info("üìä Node Info Query: {}", query);

      ResultSet resultSet = null;

      try {
         resultSet = getResultSet(query, jobContext);
      } catch (Exception e) {
         logger.error("Error in getting Node Info ResultSet, Message: {}, Error: {}", e.getMessage(), e);
      }
      return resultSet;
   }

   private static ResultSet getResultSet(String query, JobContext jobContext) {

      Map<String, String> jobContextMap = jobContext.getParameters();

      ResultSet resultSet = null;
      try {
         String SPARK_PM_JDBC_DRIVER = jobContextMap.get("SPARK_PM_JDBC_DRIVER");
         String SPARK_PM_JDBC_URL = jobContextMap.get("SPARK_PM_JDBC_URL");
         String SPARK_PM_JDBC_USERNAME = jobContextMap.get("SPARK_PM_JDBC_USERNAME");
         String SPARK_PM_JDBC_PASSWORD = jobContextMap.get("SPARK_PM_JDBC_PASSWORD");

         SPARK_PM_JDBC_DRIVER = SPARK_PM_JDBC_DRIVER != null && !SPARK_PM_JDBC_DRIVER.isEmpty()
               ? SPARK_PM_JDBC_DRIVER
               : FALLBACK_SPARK_PM_JDBC_DRIVER;
         SPARK_PM_JDBC_URL = SPARK_PM_JDBC_URL != null && !SPARK_PM_JDBC_URL.isEmpty() ? SPARK_PM_JDBC_URL
               : FALLBACK_SPARK_PM_JDBC_URL;
         SPARK_PM_JDBC_USERNAME = SPARK_PM_JDBC_USERNAME != null && !SPARK_PM_JDBC_USERNAME.isEmpty()
               ? SPARK_PM_JDBC_USERNAME
               : FALLBACK_SPARK_PM_JDBC_USERNAME;
         SPARK_PM_JDBC_PASSWORD = SPARK_PM_JDBC_PASSWORD != null && !SPARK_PM_JDBC_PASSWORD.isEmpty()
               ? SPARK_PM_JDBC_PASSWORD
               : FALLBACK_SPARK_PM_JDBC_PASSWORD;

         Class.forName(SPARK_PM_JDBC_DRIVER);
         Connection connection = DriverManager.getConnection(
               SPARK_PM_JDBC_URL, SPARK_PM_JDBC_USERNAME, SPARK_PM_JDBC_PASSWORD);

         Statement statement = connection.createStatement();
         resultSet = statement.executeQuery(query);

      } catch (Exception e) {
         logger.error("Error in getting ResultSet, Message: {}, Error: {}", e.getMessage(), e);
      }
      return resultSet;
   }

   public static List<String> getStringListFromArray(JSONArray array) {

      if (array == null || array.isEmpty()) {
         return Collections.emptyList();
      }

      List<String> list = new ArrayList<>();

      for (int i = 0; i < array.length(); i++) {

         try {
            list.add(array.getString(i));
         } catch (Exception e) {
            logger.error("Error Parsing String from JSONArray At index {} | Message: {} | Error: {}", i,
                  e.getMessage(), e);
         }

      }

      return list;
   }

   private static Map<String, String> getReportWidgetDetailsMap(Row row, JobContext jobContext) {
      Map<String, String> reportWidgetDetailsMap = new LinkedHashMap<>();
      reportWidgetDetailsMap.put("REPORT_WIDGET_ID_PK",
            row.getAs("REPORT_WIDGET_ID_PK") != null ? row.getAs("REPORT_WIDGET_ID_PK").toString() : "");
      reportWidgetDetailsMap.put("GENERATED_REPORT_ID",
            row.getAs("GENERATED_REPORT_ID") != null ? row.getAs("GENERATED_REPORT_ID").toString() : "");
      reportWidgetDetailsMap.put("REPORT_MEASURE",
            row.getAs("REPORT_MEASURE") != null ? row.getAs("REPORT_MEASURE").toString() : "");
      reportWidgetDetailsMap.put("REPORT_NAME",
            row.getAs("REPORT_NAME") != null ? row.getAs("REPORT_NAME").toString() : "");
      reportWidgetDetailsMap.put("DOMAIN", row.getAs("DOMAIN") != null ? row.getAs("DOMAIN").toString() : "");
      reportWidgetDetailsMap.put("VENDOR", row.getAs("VENDOR") != null ? row.getAs("VENDOR").toString() : "");
      reportWidgetDetailsMap.put("TECHNOLOGY",
            row.getAs("TECHNOLOGY") != null ? row.getAs("TECHNOLOGY").toString() : "");
      reportWidgetDetailsMap.put("FREQUENCY", row.getAs("FREQUENCY") != null ? row.getAs("FREQUENCY").toString() : "");
      reportWidgetDetailsMap.put("NODE", row.getAs("NODE") != null ? row.getAs("NODE").toString() : "");
      reportWidgetDetailsMap.put("CONFIGURATION",
            row.getAs("CONFIGURATION") != null ? row.getAs("CONFIGURATION").toString() : "");

      jobContext.setParameters("DOMAIN", reportWidgetDetailsMap.get("DOMAIN"));
      jobContext.setParameters("VENDOR", reportWidgetDetailsMap.get("VENDOR"));
      jobContext.setParameters("TECHNOLOGY", reportWidgetDetailsMap.get("TECHNOLOGY"));

      return reportWidgetDetailsMap;
   }

}
